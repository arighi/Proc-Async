#!/usr/bin/env perl
#
#   Usage: ./procasync --help
#
# ABSTRACT: command-line tool for executing and monitoring external processes
# PODNAME: procasync
#------------------------------------------

use strict;
use warnings;

# VERSION

use lib 'lib';  # TBD
use Proc::Async;
use Data::Dumper;

#------------------------------------------
# Command-line arguments and script usage
#------------------------------------------
my @cfg_args;
my ($opt_h, $opt_help, $opt_m, $opt_v, $opt_q);
my (@opt_start, $opt_opts, $opt_jobid, $opt_status, $opt_clean, $opt_kill, $opt_signal);
my ($opt_wdir, $opt_rlist, $opt_result, $opt_stdout, $opt_stderr, $opt_conf);
my ($undoc);

BEGIN {

    use Getopt::Long;
    use Pod::Usage;

    Getopt::Long::Configure ('no_ignore_case');
    GetOptions ( h                  => \$opt_h,
                 help               => \$opt_help,
                 man                => \$opt_m,
                 version            => \$opt_v,
                 quiet              => \$opt_q,

                 'start=s'          => \@opt_start,
                 'options=s%{1,50}' => \$opt_opts,
                 'id|jobid=s'       => \$opt_jobid,
                 status             => \$opt_status,
                 clean              => \$opt_clean,
                 kill               => \$opt_kill,
                 'signal=i'         => \$opt_signal,

                 'wdir|dir'         => \$opt_wdir,    # working directory
                 rlist              => \$opt_rlist,   # result list
                 'result=s'         => \$opt_result,  # content of a result
                 stdout             => \$opt_stdout,  # content of STDOUT
                 stderr             => \$opt_stderr,  # content of STDERR
                 'conf|cfg'         => \$opt_conf,    # contiguration

                 undoc              => \$undoc,  # undocumented

        ) or pod2usage (2);
    pod2usage (-verbose => 0, -exitval => 0) if $opt_h;
    pod2usage (-verbose => 1, -exitval => 0) if $opt_help;
    pod2usage (-verbose => 2, -exitval => 0) if $opt_m;

    # Examples for '-start':
    #   -start 'extester -stdout yes or no'
    #    ... will become (by splitting on whitespaces): ('extester', 'stdout', 'yes', 'or', 'no')
    #   -start extester -start stdout -start 'yes or no'
    #    ... will become: ('extester', 'stdout', 'yes or no')
    @opt_start = split (m{\s+}, $opt_start[0])
	if @opt_start == 1;

    # Examples for '-options':
    #   -options name1=value1 name2=value2
    $opt_opts = {} unless $opt_opts;

    sub qmsg { print STDERR shift() unless $opt_q; }

}  # end of BEGIN

# -------------------- Show version and exit ----------------------
if ($opt_v) {
    ## no critic
    no strict;    # because the $VERSION will be added only when
    no warnings;  # the distribution is fully built up
    print "$VERSION\n";
    exit(0);
}

# -------------------- Check arguments ---------------------------
sub check_jobid {
    die "Missing parameter '-jobid <value>'.\n"
	unless $opt_jobid;
}

# ------------------------ Main actions --------------------------

# --- start an external process
if (@opt_start) {
    my $jobid = Proc::Async->start ( \@opt_start, $opt_opts );
    qmsg ("ID of the started job " . join (" ", map {"'$_'"} @opt_start) . ":\n");
    print STDOUT "$jobid\n";
    if ($undoc) {
	qmsg ("$0 -jobid $jobid -status\n");
    }
    $opt_jobid = $jobid;
}

if ($opt_wdir) {
    check_jobid;
    qmsg ("Working directory for the job '$opt_jobid':\n");
    my $dir = Proc::Async->working_dir ($opt_jobid);
    print STDOUT "$dir\n" if $dir;
}

if ($opt_rlist) {
    check_jobid;
    qmsg ("List of files with results for the job '$opt_jobid':\n");
    my @files = Proc::Async->result_list ($opt_jobid);
    print STDOUT join ("\n", @files);
    print "\n" if @files > 0;
}

if ($opt_result) {
    check_jobid;
    qmsg ("File '$opt_result' of the job '$opt_jobid':\n");
    my $content = Proc::Async->result ($opt_jobid, $opt_result);
    if (defined $content) {
	print STDOUT $content;
    } else {
	my @files = Proc::Async->result_list ($opt_jobid);
	die "Result '$opt_result' does not exist or does not belong to you.\n"
	    unless exists { map {$_ => 1} @files }->{$opt_result};
    }
}

if ($opt_stdout) {
    check_jobid;
    qmsg ("STDOUT of the job '$opt_jobid':\n");
    print STDOUT Proc::Async->stdout ($opt_jobid);
}

if ($opt_stderr) {
    check_jobid;
    qmsg ("STDERR of the job '$opt_jobid':\n");
    print STDOUT Proc::Async->stderr ($opt_jobid);
}

if ($opt_kill) {
    check_jobid;
    qmsg ("Killing job '$opt_jobid': ");
    qmsg (Proc::Async->signal ($opt_jobid, 9) ? "success\n" : "failure\n");
}

if ($opt_signal) {
    check_jobid;
    qmsg ("Signalling job '$opt_jobid': ");
    qmsg (Proc::Async->signal ($opt_jobid, $opt_signal) ? "success\n" : "failure\n");
}

if ($opt_clean) {
    check_jobid;
    qmsg ("Cleaning data for the job $opt_jobid:\n");
    my $file_count = Proc::Async->clean ($opt_jobid);
    qmsg ("$file_count files for job $opt_jobid have been deleted.\n");
}

if ($opt_conf) {
    check_jobid;
    my ($cfg, $cfgfile) = Proc::Async->get_configuration ($opt_jobid);
    foreach my $name ($cfg->param) {
	foreach my $value ($cfg->param ($name)) {
	    print STDOUT "$name=$value\n";
	}
    }
}

if ($opt_status) {
    check_jobid;
    my @status = Proc::Async->status ($opt_jobid);
    qmsg ("Status of $opt_jobid: ");
    print STDOUT join (", ", @status) . "\n";
}

__END__
